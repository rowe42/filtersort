/*
* Copyright (c): it@M - Dienstleister fuer Informations- und Telekommunikationstechnik
* der Landeshauptstadt Muenchen, 2018
*/
package de.muenchen.testproject.commons.domain;


import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.transaction.Transactional;

import org.apache.lucene.search.Query;
import org.hibernate.search.jpa.FullTextEntityManager;
import org.hibernate.search.jpa.FullTextQuery;
import org.hibernate.search.jpa.Search;
import org.hibernate.search.query.dsl.BooleanJunction;
import org.hibernate.search.query.dsl.QueryBuilder;
import org.springframework.stereotype.Repository;

import de.muenchen.testproject.commons.exceptions.NoSearchableFieldException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/*
 * This file will NOT be overwritten by Barrakuda.
 * This file was automatically generated by Barrakuda.
 */
@Repository
@Transactional
public class QueryService {
	
	private static final Logger LOG = LoggerFactory.getLogger(QueryService.class);

    private static final String REGEX_GET_QUERIES = "(?:\\s*)(\\w+:\"[^\"]+\"|\\w+:[^\"\\s]+|\"[^\"]+\"|[^\"\\s]+)(?:\\s*).*";

    private static final String REGEX_CHECK_QUERY = "(\\w+):.*";

    @PersistenceContext
    private EntityManager entityManager;


    public <E extends BaseEntity> List<E> query(String text, Class<E> entity, String[] properties) {
        // get the full text entity manager
        FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager(entityManager);

        // create the query using Hibernate Search query DSL
        QueryBuilder queryBuilder = fullTextEntityManager
                .getSearchFactory()
                .buildQueryBuilder()
                .forEntity(entity)
                .get();

        // a very basic query by keywords
        Query query = queryBuilder
                .keyword()
                .fuzzy()
                .onFields(properties)
                .matching(text)
                .createQuery();

        // wrap Lucene query in an Hibernate Query object
        FullTextQuery jpaQuery = fullTextEntityManager.createFullTextQuery(query, entity);


        // execute search and return results (sorted by relevance as default)
        return jpaQuery.getResultList();
    }


    /**
     * Creates Search Query that supports Apache Lucene Terms (single terms and phrases).
     * Not supported are wildcards, Boolean Operators, Fuzzy, Range and Proximity Searches.
     * (see: https://lucene.apache.org/core/2_9_4/queryparsersyntax.html)
     * @param text The given search query containing single terms and phrases.
     * @param entity The entity to search
     * @param properties The fieldnames of the entity that where generated as searchable fields (see Barrakuda documentation)
     * @param <E> The entity type to search for
     * @return A list of entities that where found for the given query
     * @throws NoSearchableFieldException If text contains query with a non-existing or non-searchable fieldName
     */
    public <E extends BaseEntity> List<E> queryJunction(String text, Class<E> entity, String[] properties) throws NoSearchableFieldException {

        FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager(this.entityManager);
        QueryBuilder queryBuilder = fullTextEntityManager.getSearchFactory().buildQueryBuilder().forEntity(entity).get();
        Query query = null;
        if (text != null && text.length() > 0) {
            String[] queries = this.getQueries(text, properties);

            BooleanJunction boolJunction = queryBuilder.bool();

            // Loop over all queries and join them together
            for (int i = 0; i < queries.length; i++) {
                query = createSingleQuery(queries[i], queryBuilder, properties);
                boolJunction = boolJunction.must(query);
            }
            query = boolJunction.createQuery();
        } else {
            query = createSingleQuery("*", queryBuilder, properties);
        }
        FullTextQuery jpaQuery = fullTextEntityManager.createFullTextQuery(query, new Class[]{entity});
        return jpaQuery.getResultList();
	}


    /**
     * Splits search text string into query strings using regular expression: (?:\s*)(\w+:"[^"]+"|\w+:[^"\s]+|"[^"]+"|[^"\s]+)(?:\s*).*
     * Will match the following queries: value, "value with/without blank", fieldName:value, fieldName:"value with/without blank"
     *
     * Example:
     * Search text string "van der Damme" name:"de Blanc" name:Meier Meier
     * will be splitted into: "van der Damme", name:"de Blanc", name:Meier, Meier
     *
     * @param s The search text string
     * @return The search text string splitted into single query strings
     * @throws NoSearchableFieldException If text contains query with a non-existing or non-searchable fieldName
     */
    private String[] getQueries(String s, String[] properties) throws NoSearchableFieldException {

        String searchString = s.trim();

        ArrayList<String> queryList = new ArrayList<>();
        // Regular expression pattern searches for fieldName:"value" or "value" or expression that equals to value or fieldname:value
        final Pattern pattern = Pattern.compile(REGEX_GET_QUERIES);
        final int start = 0;
        int end = searchString.length();
        int groupNum = 0;

        Matcher mtch;

        while (start < end) {
            mtch = pattern.matcher(searchString);
            mtch.region(start, end);
            mtch.matches();
            groupNum = mtch.groupCount();
            String foundGroup = mtch.group(groupNum);
            
            if (this.checkQuery(foundGroup, properties)) {
                queryList.add(foundGroup);
            }
            searchString = searchString.substring(foundGroup.length()).trim();
            end = searchString.length();
        }

        String[] queries = new String[queryList.size()];
        queryList.toArray(queries);

        LOG.debug("The single splitted queries of search text \"{}\": {}", s, queries);

        return queries;

	}

    /**
     * Checks whether the query is either no fieldName-expression or a fieldname-expression with a searchable field
     * @param query The query to search for
     * @param properties The searchable fields
     * @return true if it's a query without fieldname or if the query contains a searchable field
     * @throws NoSearchableFieldException If the query contains a non-existing or non-searchable field
     */
	private boolean checkQuery(String query, String[] properties) throws NoSearchableFieldException {
	    
	    LOG.debug("The single query to check against the properties \"{}\": {}", properties, query);
	    
        Pattern p = Pattern.compile(REGEX_CHECK_QUERY);
        Matcher mtch = p.matcher(query);
        mtch.region(0, query.length());
        int j = 0;
        if (mtch.matches()) {
            j = mtch.groupCount();
            String fieldName = mtch.group(j);
            for (String prop : properties) {
                if (fieldName.equals(prop)) {
                    return true;
                }
            }

            // fieldName not found in properties => no searchable field
            throw new NoSearchableFieldException(fieldName);
        }

        return true;
    }		
    
    /**
     * Creates a {@link org.apache.lucene.search.Query} for the given term.
     *
     * @param term A lucene term (single term or phrase)
     * @param queryBuilder A builder to create a {@link org.apache.lucene.search.Query} for a single term
     * @param properties The fieldnames of the entity that where generated as searchable fields
     * @return A Query created for the given term
     */
    private Query createSingleQuery(String term, QueryBuilder queryBuilder, String[] properties) {
        Query query;
        String[] termValues = term.split(":", 2);

        if (termValues.length > 1 && !termValues[1].equals("")) {
            // if query equals to fieldName:value use phrase query to search
            if (termValues[1].startsWith("\"") && termValues[1].endsWith("\"")) {
                // remove surrounding "
                int end = termValues[1].length() - 1;
                termValues[1] = termValues[1].substring(1, end);
                query = queryBuilder.phrase().withSlop(1).onField(termValues[0]).sentence(termValues[1]).createQuery();
            } else {
                query = queryBuilder.keyword().wildcard().onField(termValues[0]).matching(termValues[1]).createQuery();
            }
        } else {
            // Otherwise search in all fields
            query = queryBuilder.keyword().wildcard().onFields(properties).matching(term).createQuery();
        }

		LOG.debug("The created single query: {}", query.toString());

        return query;
	}

}
