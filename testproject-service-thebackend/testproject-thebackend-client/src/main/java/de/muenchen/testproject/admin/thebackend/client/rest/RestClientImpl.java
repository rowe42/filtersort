/*
* Copyright (c): it@M - Dienstleister fuer Informations- und Telekommunikationstechnik
* der Landeshauptstadt Muenchen, 2018
*/
package de.muenchen.testproject.admin.thebackend.client.rest;

import lombok.Getter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.hateoas.Link;
import org.springframework.hateoas.LinkDiscoverer;
import org.springframework.hateoas.MediaTypes;
import org.springframework.hateoas.Resource;
import org.springframework.hateoas.Resources;
import org.springframework.hateoas.client.Traverson;
import org.springframework.hateoas.core.JsonPathLinkDiscoverer;
import org.springframework.hateoas.hal.HalLinkDiscoverer;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;

import java.net.URI;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/*
 * This file will be overwritten on every change of the model!
 * This file was automatically generated by Barrakuda.
 */
public abstract class RestClientImpl<T> implements RestClient<T> {

	private static final Logger LOG = LoggerFactory.getLogger(RestClientImpl.class);

	/**
	 * A String equivalent of {@link MediaType#APPLICATION_JSON_UTF8}.
	 */
	private static final String APPLICATON_JSON_VALUE_UTF_8 = "application/json;charset=UTF-8";

	/**
	 * The path template for the {@link JsonPathLinkDiscoverer}.
	 */
	private static final String PATH_TEMPLATE = "$._links..['%s']..href";

	@Getter
	private static final String FIND_FULL_TEXT_FUZZY = "findFullTextFuzzy";

	@Getter
	private static final String FIND_FULL_TEXT_JUNCTION = "findFullTextJunction";

	@Getter
	private static final String SEARCH = "search";

	/**
	 * The name of the base endpoint
	 */
	@Getter
	private final String baseEndpoint;
	
	/**
	 * The base path for the base endpoint
	 */
	@Getter
	private final URI basePath;

	/**
	 * Used to follow HATEOAS relations.
	 */
	@Getter
    private final Traverson traverson;

    /**
	 * The restTemplate used for the HTTP Requests.
	 */
	@Getter
    private final RestTemplate restTemplate;

	/**
	 * This is a simple way to get the Resources "classes" for the {@link org.springframework.web.client.RestTemplate#exchange(String, HttpMethod, HttpEntity, ParameterizedTypeReference, Object...)}.
	 */
	@Getter
	private final ParameterizedTypeReference<Resources<Resource<T>>> listParamTypeRef;

	/**
	 * This is a simple way to get the Resource "class" for the {@link org.springframework.web.client.RestTemplate#exchange(String, HttpMethod, HttpEntity, ParameterizedTypeReference, Object...)}.
	 */
	@Getter
	private final ParameterizedTypeReference<Resource<T>> paramTypeRef;

	/**
	 * Instantiates a implementation of the RestClient by RestTemplate of the server.
     * @param restTemplate The restTemplate for the HTTP Requests.
     * @param basePath The base URI of the REST Server.
     * @param baseEndpoint The base REST endpoint for this restclient.
     * @param listParamTypeRef The ParameterizedTypeReference for mapping the list of resources
     * @param paramTypeRef The ParameterizedTypeReference for mapping a resource
     */
    public RestClientImpl(final RestTemplate restTemplate, 
    						  final URI basePath, 
    						  final String baseEndpoint,
    						  final ParameterizedTypeReference listParamTypeRef,
    						  final ParameterizedTypeReference paramTypeRef) {
    	this.listParamTypeRef = listParamTypeRef;
    	this.paramTypeRef = paramTypeRef;
        this.restTemplate = restTemplate;
        this.traverson = new Traverson(basePath, MediaTypes.HAL_JSON);
        this.traverson.setRestOperations(restTemplate);
		this.traverson.setLinkDiscoverers(
				Arrays.asList(
						new HalLinkDiscoverer(),
						new JsonPathLinkDiscoverer(PATH_TEMPLATE, MediaType.valueOf(APPLICATON_JSON_VALUE_UTF_8))
				)
		);
        this.baseEndpoint = baseEndpoint;
        this.basePath = basePath;
    }

	/**
	 * {@inheritDoc}
	 */
	@Override
	public List<Resource<T>> findFullTextFuzzy(String filter) {
		return traverson.follow(baseEndpoint, SEARCH, FIND_FULL_TEXT_FUZZY)
				.withTemplateParameters(Collections.singletonMap("q", filter))
				.toObject(listParamTypeRef)
				.getContent()
				.stream()
				.collect(Collectors.toList());
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public List<Resource<T>> findFullTextJunction(String filter) {
		return traverson.follow(baseEndpoint, SEARCH, FIND_FULL_TEXT_JUNCTION)
				.withTemplateParameters(Collections.singletonMap("q", filter))
				.toObject(listParamTypeRef)
				.getContent()
				.stream()
				.collect(Collectors.toList());
	}

	/**
	 * {@inheritDoc}
	 */
	@Override 
	public List<Resource<T>> findAll() {
		return traverson
				.follow(baseEndpoint)
				.toObject(listParamTypeRef)
				.getContent()
				.stream()
				.collect(Collectors.toList());
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public List<Resource<T>> findAll(Link relation) {
		URI uri = URI.create(relation.getHref());
		return restTemplate
		 		.exchange(uri, HttpMethod.GET, null, listParamTypeRef)
		 		.getBody()
		 		.getContent()
				.stream()
				.collect(Collectors.toList());
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Optional<Resource<T>> findOne(Link link) {
	    URI uri = URI.create(link.getHref());
		try {
			return Optional.of(
					restTemplate
						.exchange(uri, HttpMethod.GET, null, paramTypeRef)
						.getBody()
			);
		} catch (HttpClientErrorException e) {
			final HttpStatus statusCode = e.getStatusCode();
			if (!HttpStatus.NOT_FOUND.equals(statusCode))
				throw e;
			if (Link.REL_SELF.equals(link.getRel()))
				throw e;
			return Optional.empty();
		}
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void setRelations(Link endpoint, Collection<Link> links) {
		String relations = links.stream().map(Link::getHref).collect(Collectors.joining("\n"));
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(new MediaType("text", "uri-list"));
		restTemplate.exchange(URI.create(endpoint.getHref()), HttpMethod.PUT, new HttpEntity<>(relations, headers), Void.class);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
    public void setRelation(Link endpoint, Link relation) {
    	Optional<Link> rel = Optional.ofNullable(relation);
		if (rel.isPresent()) {
			HttpHeaders headers = new HttpHeaders();
			headers.setContentType(new MediaType("text", "uri-list"));
			restTemplate.exchange(URI.create(endpoint.getHref()), HttpMethod.PUT, new HttpEntity<>(rel.map(Link::getHref).orElse(""), headers), Void.class);
		} else {
			this.delete(endpoint);
		}
    }

	/**
	 * {@inheritDoc}
	 */
	@Override
    public void updateRelations(Link endpoint, Collection<Link> links) {
    	String relations = links.stream().map(Link::getHref).collect(Collectors.joining("\n"));
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(new MediaType("text", "uri-list"));
        restTemplate.exchange(URI.create(endpoint.getHref()),
				HttpMethod.PATCH, 
				new HttpEntity<>(relations, headers), 
				Void.class);
     }

	/**
	 * {@inheritDoc}
	 */
	@Override
    public void updateRelation(Link endpoint, Link relation) {
    	Optional<Link> rel = Optional.ofNullable(relation);
        if (rel.isPresent()) {
        	HttpHeaders headers = new HttpHeaders();
            headers.setContentType(new MediaType("text", "uri-list"));
            restTemplate.exchange(URI.create(endpoint.getHref()),
					HttpMethod.PATCH, 
					new HttpEntity<>(rel.map(Link::getHref).orElse(""), headers),
					Void.class);
        } else {
        	this.delete(endpoint);
        }
     }

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Resource<T> create(T payload) {
		URI uri = URI.create(
				traverson.follow(baseEndpoint).asLink().getHref()
		);
		return restTemplate
				.exchange(uri, HttpMethod.POST, new HttpEntity<>(payload), paramTypeRef)
				.getBody();
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public Resource<T> update(Resource<T> resource) {
        URI uri = URI.create(resource.getId().getHref());
        return restTemplate
				.exchange(uri, HttpMethod.PUT, new HttpEntity<>(resource.getContent()), paramTypeRef)
				.getBody();
    }

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void delete(Link id) {
		URI uri = URI.create(id.getHref());
		restTemplate.exchange(uri, HttpMethod.DELETE, null, Void.class);
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public void delete(Resource<T> resource) {
		delete(resource.getId());
	}

}
