<!--
  This file will be overwritten on every change of the model!
  This file was automatically generated by Barrakuda.
-->
<link rel="import" href="../common-libs/common-utils.html">
<link rel="import" href="../common-libs/jsonpointer.html">
<script>
    /*
     * Behavior, um einem beliebigen Formular (Update, Create, Read) alle Eigenschaften
     * wie Properties und Methoden zu geben, die es benötigt um mit dem Server zu
     * kommunizieren.
     *
     * @polymerMixin
     */
    let TestprojectFormBehavior = (superClass) => class extends superClass {

            static get properties() {
                return {
                    /*
                     * Url um die Formulardaten zu laden.
                     */
                    loadUrl: {
                        type: String,
                        notify: true,
                        observer: '_loadFormData'
                    },
                    /*
                     * Url um die Formulardaten zu speichern.
                     */
                    saveUrl: {
                        type: String,
                        observer: '_prepareCreateForm'
                    },
                    profileUrl: {
                        type: String,
                        observer: '_loadProfile'
                    },
                    /*
                     * Das leere Objekt.
                     */
                    data: {
                        type: Object,
                        notify: true
                    },
                    profile: {
                        type: Object,
                        notify: true,
                        observer: '_parseProfile'
                    },
                    defaults: {
                        type: Object
                    },
                    lists: {
                        type: Object,
                        value: {},
                        notify: true
                    },
                    /*
                     * Über dieses Property wird gesteuert, ob im Formular eine
                     * 'Cancel' Schalfläche angezeigt werden soll.
                     * Nach Anklicken der Schaltfläche 'Cancel' wird zum Wert von cancelPath
                     * navigiert.
                     */
                    cancelPath: {
                        type: String
                    },
                    /*
                     * Nach Anklicken der Schaltfläche 'Save' wird zum Wert von savePath
                     * navigiert.
                     */
                    savePath: {
                        type: String
                    },
                    /*
                     * Wenn dieses Property gesetzt ist, dann wird unter dem Formular
                     * eine 'Reset' Schaltfläche angezeigt, mit der man das Formular
                     * (und ggf. die Relationen) löschen kann.
                     */
                    reset: {
                        type: Boolean,
                        value: false
                    },
                    _initialReadform: Boolean,
                    /*
                     *
                     */
                    _error: {
                        type: String
                    },
                    /*
                     *
                     */
                    _errorToast: {
                        type: Object
                    },
                    /*
                     *
                     */
                    _successToast: {
                        type: Object
                    },
                    /*
                     *
                     */
                    _warningToast: {
                        type: Object
                    }
                }
            }

            connectedCallback() {
                super.connectedCallback();
                this._initialReadform = this.readform || false;
            }

            /*
             * Wird von Formularen in Buttons aufgerufen.
             Navigiert zum Attribut "data-routePath" wenn der Button gedrückt wird.
             */
            _navigateTo(e) {
                var routePath = e.target.dataset.routepath;
                console.log("navigiere zu:" + routePath);
                this.set("route.path", routePath);
            }

            /*
             * Wird von 'cancel' in Formularen aufgerufen.
             */
            _cancelEntity(e) {
                e.target.dataset.routepath = this.cancelPath;
                this._navigateTo(e);
            }
            
            /*
             * Wird von 'cancel' in Formularen aufgerufen welche das Formular auch zurücksetzen wollen.
             */
            _cancelAndResetEntity(e) {
                this._resetForm();
                this._cancelEntity(e);
            }
            
            /*
             * Wird von 'cancel' in Formularen aufgerufen welche das Formular neu laden wollen.
             */
            _cancelAndReloadEntity(e) {
            	this._nonEditForm();
                this._reloadForm();
                this._cancelEntity(e);
            }

            /*
             * Wird von 'create' Formularen aufgerufen, um eine neue Entität
             * zu speichern.
             */
            _saveEntity(e) {
                e.target.dataset.routepath = this.savePath;
                this._send('POST', this.saveUrl, this.data, e);
            }

            /*
             * Wird von 'update' Formularen aufgerufen, um eine bereits
             * bestehende Entität zu aktualisieren.
             */
            _updateEntity(e) {
                e.target.dataset.routepath = this.savePath;
                var updateOk = this._send('PATCH', this.loadUrl, this.data, e);
                if (updateOk == true) {
                    this._nonEditForm();
                }
            }

            /**
             * Validiert die Formulardaten. Danach werden sie an die angegebene
             * URL als JSON Objekt gesendet.
             * @return {boolean} true, wenn Form valide und Backend mit OK antwortet
             */
            _send(verb, url, payload, e) {
                var ok = false;
                // check if the form content is valid against the defined rules
                var valid = this.shadowRoot.querySelector('#customform').validate();
                if (valid) {
                	
                	//für Vererbung schicken wir noch jeweils den Typ des Objekts mit
                	if (!payload['dtype']) {
                	  payload['dtype'] = this._entity  + "_";
                	}

                    // prepare request
                    var init = {
                        method: verb,
                        mode: 'cors',
                        credentials: 'include',
                        body: JSON.stringify(payload),
                        headers: new Headers({
                            'Content-Type': 'application/json'
                        })
                    }

                    var request = new Request(url, init);

                    fetch(request)
                        .then(response => {
                            if (response.ok) {
                              if ((verb === 'POST'  || verb === 'PATCH' || verb === 'PUT') && typeof this._resetForm === "function") {
                                  this._resetForm();
                              } else {
                                  console.warn('Cannot find mixin "*-form-behavior.html"!');
                              }
                              if (verb === 'POST' || verb === 'PATCH' || verb === 'PUT') {
                                 //Event, dass etwas im Backend an den Entities geändert hat --> reload der Table/List
                                 this.dispatchEvent(new CustomEvent(this._entity + 'Reload', {
                                     bubbles: true,
                                     composed: true,
                                     detail: {kicked: true}
                                 }));
                              }
                              this._success('form_success');
                              ok = true;
                          } else {
                            this._error(response.status, '_send', 'form_action_send');
	                        if ((verb === 'PATCH' || verb === 'PUT') && response.status >= 400 && response.status <= 499) {
	                          this._reloadForm();
	                        }
                          }
                      }).catch(error => {
                        this._error(500, '_send', 'form_action_send');
                      });
                    // navigiere zu data-routePath wenn form o.k.
                    this._navigateTo(e);
                } else {
                    console.warn("form is not valid...");
                    this._warning('form_validation');
                }
                return ok;
            }

            /*
             * Holt sich eine HAL Resource über die URL, die im Property
             * 'loadUrl' gespeichert ist. Die Nutzdaten werden im 'data'
             * Property gespeichert. Danach werden alle benötigten Links
             * aufgelöst.
             *
             * Das Property 'loadUrl' wird ausschließlich von update und read
             * Formularen verwendet.
             */
            _loadFormData(loadUrl, oldV) {
                if (loadUrl)
                    this._loadHalData(loadUrl, 'GET', 'data');
            }
            
            _prepareCreateForm(saveUrl) {
                this._prepareGenericCreateForm(saveUrl, 'data');
            }
            
            _prepareGenericCreateForm(saveUrl, target) {
                if (saveUrl) {
                    //zunächst die Defaults laden, falls verfügbar
                    this._loadHalData('/defaults/' + this._domain + '_' + this._entity.toLowerCase() + '_defaults.json', 'GET', 'defaults', 
                        //danach die OPTIONS laden
                        function() { this._loadOptions(saveUrl, target,
                            //dann Defaults und Options zusammenführen
                            function() {
                                if (this.defaults && this.defaults[this.lang]) {
                                    let localizedDefaults = this.defaults[this.lang];
                                    let targetObj = this.get(target);
                                    Object.keys(localizedDefaults).forEach(key => {
                                       if (localizedDefaults[key] != null) {
                                         targetObj[key] = localizedDefaults[key];
                                         this.notifyPath(target + '.' + key);
                                       }
                                    });
                                }
                            }.bind(this) 
                        )}.bind(this)
                    );
                }
            }

            /*
             * Holt sich eine HAL Resource per OPTIONS Verb.
             * In dieser Ressource sind bei einem create
             * Formular die Links zu den Ressourcen Objekten
             * gespeichert.
             *
             * Das Property '_loadOptions' wird ausschließlich
             * von create Formularen verwendet.
             */
            _loadOptions(saveUrl, target, customFunc) {
                if (saveUrl) {
                    this._loadHalData(saveUrl, 'OPTIONS', target, customFunc);
                }
            }
            
            /*
             * Lädt das zugrunde liegende Data-Objekt neu
             */
            reload() {
                this.readform = this._initialReadform;
                if (this.loadUrl) {
                    this._loadFormData(this.loadUrl);
                }
                if (this.saveUrl) {
                    this._loadOptions(this.saveUrl);
                }
            }

            _loadProfile(profileUrl, oldV) {
                // prepare request
                var init = {
                    method: 'GET',
                    credentials: 'include',
                    headers: {
                        "Accept": "application/schema+json"
                    }
                }

                var request = new Request(profileUrl, init);
                return fetch(request)
                    .then(response => {
                        if (response.ok) {
                            response.json().then((data) => {
                                this.set("profile", data);
                            });
                        } else {
                            this._error(response.status, '_loadProfile', 'form_action_load');
                        }
                    }).catch(error => {
                        this._error(500, '_loadProfile', 'form_action_load');
                    });
            }

            _parseProfile(profile) {
                if (profile) {
                    var entityTitle = profile.title;
                    console.log("Parsing json-schema metadata for " + entityTitle);
                    var properties = profile.properties;
                    if (properties.length === 0) {
                        console.warn('No properties found in profile!');
                    }
                    Object.entries(properties).forEach(([key, value]) => {
                        this._checkAttributeForLists(profile, key, value);
                    });
                } else {
                    console.warn('Called _parseProfile, but with no profile provided!');
                }
            }
            
            _checkAttributeForLists(profile, key, value) {
                    var property = key;
                    if (value.enum) {
                        // found customListType
                        this.lists[property] = value.enum;
                        console.log("Parsed listItems for '" + property +"': " + value.enum);
                        this.notifyPath('lists.' + property);
                    } else if(value.type === "object") {
                        console.log("Property '" + property + "' is an embeddded object...");
                        var definitionRef = value.$ref;
                        // use jsonpointer.js
                        console.log("Looking up json-pointer: " + definitionRef);
                        var objectDef = jsonpointer.get(profile, definitionRef);
                        if (objectDef.properties && objectDef.properties.length !== 0) {
                            var props = objectDef.properties;
                            Object.entries(props).forEach(([key, value]) => {
                                this._checkAttributeForLists(profile, key, value);
                            });
                        }
                    } else if(value.type === "array") {
                        // check if description contains possible values (eg. animad skills via rest-messages.properties)
                        if(value.description) {
                            var values = CommonUtils.simpleCsvToArray(value.description);
                            console.log("Parsed listItems for '" + property +"': " + value.description);
                            this.lists[property] = values;
                    	    this.notifyPath('lists.' + property);
                        }
                    }
            }


            
            _loadHalData(url, verb, target, customFunc) {
                if (!url || !verb || !target) {
                    return;
                }
                
                // prepare request
                var init = {
                    method: verb,
                    mode: 'cors',
                    credentials: 'include'
                }

                var request = new Request(url, init);

                return fetch(request)
                        .then(response => {
                            if (response.ok) {
                                response.json().then((data) => {
                                    this.set(target, data);
                                    //jetzt die übergebene Funktion ausführen, falls verfügbar
                                    if (customFunc) {
                                        customFunc();
                                    }
                                });
                            } else {
                                this._error(response.status, '_loadHalData', 'form_action_load');
                            }
                        }).catch(error => {
                          this._error(500, '_loadHalData', 'form_action_load');
                        });
            }

            _reloadForm() {
                this._loadFormData(this.loadUrl, null);
            }

            _resetForm(event) {
                this._resetFormWithObject('data');
            }
            
            /*
             * Setzt das Formular zurück.
             */
            _resetFormWithObject(obj) {
                this.autoValidate = false;
            
                //reset Form
                let customform = this.shadowRoot.querySelector('#customform');
                this._resetFields(customform, this._entity);
                
                //reset Relations
                let containingform = this.shadowRoot.querySelector('#containingform');
                this._resetRelations(containingform, this._entity);
                
                //nur zur Sicherheit auch nochmal alle Felder von 'data' löschen (damit auch nicht 
                //Einträge entfernt werden, die kein Feld haben)
                this._resetDataObject(obj);
                
                this.set(obj + '._embedded', null);
                this.autoValidate = true;
            }
            
            _resetFields(base, entityName) {
                let fields = base.shadowRoot.querySelectorAll('[id^=' + entityName + ']');
                fields.forEach(field => {
                    if (field.id) {
                        let fieldNameParts = field.id.split('-');
                        if (fieldNameParts.length >= 3 && fieldNameParts[2] === 'valueobject') {
                            this._resetFields(field, fieldNameParts[1]);
                        }
                    }
                    let tempRequired = field.required;
                    field.required = null;
                    field.value = null;
                    field.required = tempRequired;
                }, this);
            }
            
            _resetDataObject(obj) {
                Object.keys(this.get(obj)).forEach(key => {
                    if (key != '_links') {                        
                        let entry = this.get(obj + '.'+key);
                        if (entry instanceof Array) {
                            this.set(obj + '.' + key, []);
                        } else if (entry instanceof Object) {
                            this._resetDataObject(obj + '.'+key );
                        } else {
                            this.set(obj + '.' + key, null);
                        }
                    }
                });
            }

            _resetRelations(base, entityName) {
               let relations = base.querySelectorAll('[id^=' + entityName + 'Relation]');
               relations.forEach(relation => {
                  relation._resetRelation();
               });
            }

            /*
             * Macht ein 'readonly' Formular editierbar.
             */
            _editForm() {
                if (this.readform) {
                    this.set('readform', false);
                }
            }
            
            /*
             * Macht ein editierbares Formular wieder zu einem 'readonly' Formular.
             */
            _nonEditForm() {
                if (!this.readform) {
                    this.set('readform', true);
                }
            }
			
            /*
            * Wird in der Komponente verwendet um den Parameter dtype
            * in einem List-Item zu überprüfen.
            */
            _dataIsOfType(data, type) {
              return (data.dtype === type);
            }
            
            _dataIsOfTypeOrNull(data, type) {
              if (!data.dtype) {
                  return true;
              } else {
                  return this._dataIsOfType(data, type);
              }
            }

            /*
             * Der 'Toast', der bei Erfolg angezeigt wird.
             */
            _success(key) {
                const notification = {
                        type: 'success',
                        message: this.$t(key),
                    }
                    const e = new CustomEvent('notify', {
                        detail: notification,
                        bubbles: true,
                        composed: true,
                    })
                    this.dispatchEvent(e)
            }
            
            /*
            * Der 'Toast', der bei Nicht-Erfolg angezeigt wird.
            */
            _warning(key) {
            	const notification = {
            		type: 'warning',
            		message: this.$t(key),
            	}
            	const e = new CustomEvent('notify', {
            		detail: notification,
            		bubbles: true,
            		composed: true,
            	})
            	this.dispatchEvent(e)
            }
            
        };
</script>
