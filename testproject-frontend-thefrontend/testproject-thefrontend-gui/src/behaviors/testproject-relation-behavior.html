<!--
  This file will be overwritten on every change of the model!
  This file was automatically generated by Barrakuda.
-->
<link rel="import" href="../common-libs/halson.html">

<script>
    /*
     * Behavior, um einem Relation Element mit den notwendigen Eigenschaften
     * auszustatten, um Relationen zu einem Zielobjekt hinzu zu fügen und
     * wieder zu entfernen. Um korrekt funktionieren zu können,
     * muss das Element die Properties '_domain' und '_entity' setzen:
     *
     * ```javascript
     *  _domain: {
     *    type: String,
     *    value: 'testproject'
     *  },
     *  _entity: {
     *    type: String,
     *    value: 'enclosure'
     *  }
     * ```
     *
     * Eingebunden wird das Mixin auf Klassenebene.
     *
     * @polymerMixin
     */
    let TestprojectRelationBehavior = (superClass) => class extends superClass {
        static get properties() {
            return {
                /*
                 * Der Daten-Cache.
                 */
                source: {
                    type: Array,
                    value() {
                        return [];
                    },
                    notify: true
                },
                /*
                 * Legt fest, ob die Daten vorab in den Speicher
                 * geladen werden. Dies ist bei kleinen Datenmengen
                 * durchaus sinnvoll. Die Daten werden in dem
                 * Augenblick geladen, in dem die Komponente
                 * gerendert wird.
                 */
                preload: {
                    type: Boolean,
                    value: false
                },
                /*
                 * Legt fest, ob eine neu hinzugefügte Relation per ID
                 * oder als komplette eingebettete Entität angelegt wird.
                 */
                saveRelationById: {
                    type: Boolean,
                    value: true
                },
                /*
                 * Die übergeordnete Datenstruktur, um das Datenbinding
                 * durchgängig zu machen.
                 */
                data: {
                    type: Object,
                    notify: true,
                    observer: '_loadRelationData'
                },
                /*
                 * Falls gesetzt  wird beim Anhängen zunächst überprüft, ob die  anzuhängende Entität
                 * bereits an einer anderen Entität hängt.
                 * Wert: 'create' falls in einer Create-Form, 'update' falls in einer Update-Form
                 */                
                oneToManyCheck: {
                    type: String,
                    value: null
                },
                /*
                * Soll die Relation nur lesend dargestellt werden?
                */
                readonly: {
                    type: Boolean,
                    value: false
                },                 
                /*
                 * Wenn in der HAL Nachricht ein Link vorhanden ist, der
                 * es ermöglicht ein neues Objekt für die Relation zu
                 * erstellen, dann wird dieses Property auf 'true' gesetzt.
                 * Dadurch wird ein 'new' Button neben dem Suchfeld
                 * dargestellt.
                 */
                _new: {
                    type: Boolean,
                    value: false,
                    notify: true
                },
                /*
                 * Der Link um ein neues Objekt für die Relation zu erstellen.
                 */
                _newUrl: {
                    type: String,
                    observer: '_prepareDialogCreateForm'
                },
                /*
                 * Das Formularobjekt für den Dialog um Relationen 'on the fly'
                 * erstellen zu können.
                 */
                _dialogdata: {
                    type: Object,
                    value: {},
                    notify: true
                },
                entityFirstLower: {
                    type: String
                },
                relationName: {
                    type: String
                },
                relationType: {
                    type: String
                },
                _embeddedItems: {
                    type: Array,
                    value: function() { return []; } //wichtig: bei "value: []" würde ein Objekt über alle Instanzen verwendet...!
                },
                _deleteItem: Object,
                autocompleteText: String
            }
        }

        connectedCallback() {
            super.connectedCallback();
            this.entityFirstLower = this._entity.charAt(0).toLowerCase() + this._entity.slice(1);

            // Es muss ein eventlistener registriert werden,
            // um die selektierten Elemente verarbeiten zu
            // können.
            var e = this.shadowRoot.querySelector('paper-autocomplete');
            e.addEventListener('autocomplete-selected', this._appendItem);
          	e.addEventListener('autocomplete-change', this._loadSuggestions);

            // Die generische Query Methode muss
            // durch eine eigene Methode überschrieben
            // werden.
            e.queryFn = this._querySimple;
        }

		/*
         * Wird ein Traversal Objekt übergeben, dann werden automatisch
         * die vorhandenen Daten geladen. Dies sind einerseits die zur
         * Entität gehörenden Relationen, andererseits werden die möglichen
         * Relationen vorgeladen (sofern das 'preload' Attribut gesetzt ist).
         *
         * @param   das neue Traversal Objekt
         * @param   der bisherige Wert des Propeties (wird nicht benötigt)
         */
        _loadRelationData(data, oldV) {

            if (data) {

                // Der Link Alias entspricht dem Namen der Relation
                var link = this.relationName;

                // Bereits vorhandene Relationen werden geladen und
                // in das Feld _embeddedItems abgelegt.
                // Hinweis: Unter data.[relationName] sind die zugehörigen
                // Links enthalten.

                // Das HAL Objekt wird eingelesen.
                var hal = halson(data);

                // Die bereits verknüpften Relationen
                // werden geladen. Wenn sie vorhanden sind.
                var entityRelations = hal.getLink(link);
                if (entityRelations) {
                    var init = {
                        method: 'GET',
                        mode: 'cors',
                        credentials: 'include'
                    }

                    var request = new Request(entityRelations.href, init);

                    fetch(request)
                        .then(response => {
                           if (response.ok) {
                               response.json().then((data) => {
                               //die Links auf die referenzierten Entities kommen nach data.[relationName]
                               var refName = 'data.' + this.relationName;

                               if (this.relationType.endsWith("ToOne")) {
                                  //bei *toOne-Beziehungen ist die Referenz nicht unter data._embedded zu finden
                                  var link = data._links.self.href;
                                  this.set(refName, link);
                                  
                                  //die ID explizit setzen, damit man sie später für delete verwenden kann
                                  let id = this._stripUrlFromId(link);
                                  data['id'] = id;
                                  
                                  this._embeddedItems = [data];
                               } else if (this.relationType.endsWith("ToMany")) {
                                  var array = data._embedded[this.entityFirstLower + 's'];
                                  
                                  //die ID explizit setzen, damit man sie später für delete verwenden kann
                                  array.forEach(element => element['id'] = this._stripUrlFromId(element._links.self.href));
                                  
                                  var linkArray = array.map(entity => halson(entity).getLink('self').href);
                                  
                                  this.set(refName, linkArray);

                                  //der eigentliche Content der referenzierten Entities kommt nach embeddedItems
                                  this._embeddedItems = array;
                               } else {
                                  console.warn('Relation Type ' + this.relationType + ' of relation ' + this.relationName + ' not recognized!');
                               }

                           });
                        } else {
                           
                           if (response.status === 404 && (this.relationType === "manyToOne" || this.relationType === "oneToOne")) {
                               this._embeddedItems = [];
                               console.log("Response " + response.status + " in method \"TestprojectRelationBehavior._loadRelationData\".");
                               console.log("This response can be caused due to a wrong URL\n or due to a not available object in a relational " + this.relationType + " attribute.");
                               console.log("The responsible link: " + entityRelations.href)
                           } else {
                               this._error(response.status, '_loadRelationData', 'form_action_load');
                           }
                           
                        }
                    })
                }

                // Es wird initial geprüft, ob in der Payload ein Link
                // vorhanden ist, der es ermöglicht Relationsobjekte
                // 'on the fly' zu erstellen.
                var allRelations = hal.getLink(this.entityFirstLower + 's');
                if (allRelations) {
                    var url = allRelations.href;
                    this.set('_new', true);
                    this.set('_newUrl', url);
                    
                    if (this.preload) {
                        this._loadAutocompleteEntries(null, null);
                    }
                }
            }
        }

        /*
         * Sucht im Backend für den aktuellen Entitätstyp nach Entitäten, die 
         * den searchString erfüllen und platziert diese im Objekt 'autocompleter'.
         *
         * @param   der searchString
         * @param   das autocompleter Objekt, das es zu befüllen gilt
         */
        _loadAutocompleteEntries(searchString, autocompleter) {
            // Das HAL Objekt wird eingelesen.
            var hal = halson(this.data);
            var allRelations = hal.getLink(this.entityFirstLower + 's');
            if (searchString) {
                var baseUrl = allRelations.href; //HACK: eigentlich sollte man das aus allRelations raus kriegen --> dazu Options erweitern            
                var url=baseUrl+'/search/findFullTextJunction?q=' + searchString.toLowerCase() + '*';
            } else {
                var url = allRelations.href;
            }
            
            var init = {
            			    method: 'GET',
            			    mode: 'cors',
            			    credentials: 'include'
            }

            var request = new Request(url, init);

            fetch(request)
                .then(response => {
                    if (response.ok) {
                        response.json().then((data) => {
                        	//zurücksetzen, falls bereits vormals geladen wurde (alter Stand!)
                        	this.set('source', []);
                            if (data && data._embedded) {
                                var array = data._embedded[this.entityFirstLower + 's'];
                                array.forEach((element) => {
                                    // der formatierte Text zur Auswahl
                                    var text = this._formatSuggester(element);
                                    // die id im Item ergänzen
                                    var value = element._links.self.href;
                                    var index = value.lastIndexOf('/') + 1;
                                    var itemId = value.substring(index);
                                    element["id"] = itemId;

                                    // Die beiden Werte als Objekt in das 'suggestions' Array
                                    // speichern. Dieses Array ist Quelle für die
                                    // Autocomplete Componente.
                                    this.push('source', { "text": text, "value": value, "entity": element })
                                });
                            }
                            if (autocompleter) {
                                autocompleter.suggestions(this.source);
                            }
                        });
                    } else {
                       this._error(response.status, '_loadRelationData', 'form_action_load');
                    }
                })
        }


        /*
         * Wird ein Traversal Objekt übergeben, dann werden automatisch
         * die Relationen zur aktuellen Entität gespeichert. Dazu wird
         * ein separater PUT-Request an den unter _links verfügbaren [entity]Link
         * geschickt.
         * Achtung: Da ein PUT verwendet wird, werden alle bestehenden Relationen
         * gelöscht. Man muss also darauf achten, auch die bestehenden Relationen,
         * die man behalten will, mitzuschicken.
         *
         * @param   das neue Traversal Objekt
         * @param   eine übergebene Funktion, die nach Erfolg des Speicherns ausgeführt werden soll
         */
        _saveRelationData(data, chainFunc) {
            if (data) {

                // Der Link Alias entspricht dem Namen der Relation
                var link = this.relationName;
                
                // Das HAL Objekt wird eingelesen.
                var hal = halson(data);
                
                //der Link, zu dem der PUT Request erfolgen soll
                var entityRelationLink = hal.getLink(link).href;
                
                //die Relationen, die gespeichert werden sollen,
                //liegen unter dem Property, das genauso heißt wie der Link
                var relationsToSave = data[link];
                
                //wir erzeugen eine neue text/uri-list
                var uriListBody = "";
                if (relationsToSave instanceof Array) {
                    relationsToSave.forEach((relation, i) => uriListBody+= relation + "\r\n");
                } else {
                   	//bei *toOne-Relationen enthält relationsToSave kein Array
                    uriListBody += relationsToSave;
                }
                
                if ((this.relationType === "manyToOne" || this.relationType === "oneToOne") && (relationsToSave === undefined || relationsToSave.length == 0)) {
                
                	var init = {
                    	method: 'DELETE',
                        mode: 'cors',
                        credentials: 'include'
                    }
                
                } else {
                
                	//und speichern
                    var init = {
                    	method: 'PUT',
                        mode: 'cors',
                        credentials: 'include',
                        body: uriListBody,
                        headers: new Headers({
                        	'Content-Type': 'text/uri-list'
                        })
                    }
                
                }
                    
                var request = new Request(entityRelationLink, init);

                fetch(request)
                        .then(response => {
                            if (!response.ok) {
                              this._error(response.status, '_saveRelationData', 'form_action_send');
                            } else {
                              if (chainFunc != undefined) chainFunc();
                            }
                        })
            }
        }
        
        /*
         * Öffnet den Dialog um ein neues Relationsobjekt
         * 'on the fly' anlegen zu können.
         */
        _showDialog() {
            // Dialog wird geöffnet
            this.shadowRoot.querySelector('paper-dialog').open();
        }

        /*
         * Schließt das Dialogfenster und versucht den inhalt des Formulares
         * zu speichern. Gelingt dies, so wird das Objekt sofort der Relationen
         * Liste hinzugefügt.
         */
        _saveDialog() {

            // check if the form content is valid against the defined rules
            var valid = this.shadowRoot.querySelector('#customform').validate();

            if (valid) {
                let payload = this._dialogdata;
            
                //für Vererbung schicken wir noch jeweils den Typ des Objekts mit
                if (!payload['dtype']) {
                  payload['dtype'] = this._entity  + "_";
                }

                // prepare request
                var init = {
                    method: 'POST',
                    mode: 'cors',
                    credentials: 'include',
                    body: JSON.stringify(payload),
                    headers: new Headers({
                        'Content-Type': 'application/json'
                    })                    
                }

                var request = new Request(this._newUrl, init);



                fetch(request)
                    .then(response => {
                        if (response.ok) {
                            // Formular zurücksetzen
                            if (typeof this._resetForm === "function") {
                                this._resetDialog();
                            } else {
                                console.warn('Cannot find mixin "*-form-behavior.html"!');
                            }
                            
                            //Event, dass etwas im Backend an den Entities geändert hat --> reload der Table/List
                            this.dispatchEvent(new CustomEvent(this._entity + 'Reload', {
                            	bubbles: true,
                            	composed: true,
                            	detail: {kicked: true}
                            }));
                            	    
                            // 'Erfolgs' Toast öffnen
                            if (typeof this._success === "function") {
                                this._success('form_success');
                            } else {
                                console.warn('Cannot find mixin "*-form-behavior.html"!');
                            }

                            // Wenn das Objekt erfolgreich gespeichert wurde, dann
                            // kann es gleich in die Auswahlliste gepusht werden.
                            response.json().then((d) => {
                                var id = halson(d).getLink('self').href;
                                //die ID im Objekt ergänzen
                                var index = id.lastIndexOf('/') + 1;
                                var itemId = id.substring(index);
                                d['id'] = itemId;
                                
                                this._appendItemInternal(this, id, d);

                            })

                        } else {
                            // Wenn ein Fehler aufgetreten ist, dann wird dieser
                            // über einen Toast dem nutzer mitgeteilt.
                            if (typeof this._error === "function") {
                              this._error(response.status, '_saveDialog', 'form_action_send');
                            } else {
                                console.warn('Cannot find mixin "*-form-behavior.html"!');
                                console.error('Cannot call ' + this._newUrl + '. Error Code: ' + response.status);
                            }
                        }
                    })
            }

        }

        _resetDialog() {
            this._resetFormWithObject('_dialogdata');
        }
        
        _resetRelation() {
            this._embeddedItems = [];
            this.autocompleteText = null;
        }
        
        _prepareDialogCreateForm(saveUrl) {
            this._prepareGenericCreateForm(saveUrl, '_dialogdata');
        }
        
        /*
         * Sucht in einer vorgeladenen Quelle (Property preload
         * ist auf 'true' gesetzt) nach Vorkommen einer Zeichenkette
         * im Attribut, dass im Property 'textProperty' angegeben wurde.
         *
         * @param die Auswahlliste Liste
         * @param die Such-Zeichenkette
         * @return ein Array der selektierten Elemente
         */
        _querySimple(datasource, query) {
            return datasource.filter(x => x[this.textProperty].toLowerCase().indexOf(query) != -1);
        }
        
		/*
         * Listener Methode, um ein ausgewähltes Element der
         * Zielstruktur hinzu zu fügen.
         *
         * @param Event mit den notwendigen Daten
         */
         _appendItem(event) {
            // Der 'host' des Elternknotens wird benötigt
            // um an die Properties zu kommen, da wir nicht
            // im 'this' scope sind.
            var h = this.parentNode.parentNode.parentNode.host;
            var id = event.detail.value;

            var item = this.source.find(x => x.value === id);

            if (h.oneToManyCheck) {
                //zunächst die oneToMany-Relation prüfen
                h._isRelationTarget(id, function() { h._appendItemInternal(h, id, item.entity); } );
            } else {
                //gleich anhängen
                h._appendItemInternal(h, id, item.entity);
            }

            // Textfeld leeren
            event.currentTarget.clear();
        }
        
        _loadSuggestions(event) {
            var h = this.parentNode.parentNode.parentNode.host;
            let element = event.target;
            let searchString = event.detail.value;
            let suggestion = h._loadAutocompleteEntries(searchString, element);
        }	    
       
       
       _appendItemInternal(h, id, entity) {
            var name = 'data.' + h.relationName;
            var type = h.relationType;
       
            if (type === null || type === undefined) {
                console.error('Relationstyp fehlt bei relation ' + h.id);
            } else if (type.endsWith("ToMany")) {
       
                // Wenn noch kein Attribut vorhanden ist, um
                // die Referenz zu speichern, so muss eines
                // mit einem leeren Array erzeugt werden.
                if (!h.get(name)) {
                    h.set(name, []);
                }
       
                // Wenn das Property 'save-relation-by-id' gesetzt ist...
                if (h.saveRelationById) {
                    // Der key der ausgewählten Referenz wird
                    // im Array gespeichert.
                    h.push(name, id);
                } else {
                    // Das Relationsobjekt wird gespeichert
                    var item = this.source.find(x => x.value === id);
                    h.push(name, entity);
                }
       
            } else if (type.endsWith("ToOne")) {
                if(h.get(name)){
                	this.set(name, []);
                    h.pop('_embeddedItems');
                }
                h.set(name, id);
       
            } else { console.error('Relationstyp fehlerhaft bei relation ' + h.id) }
       
            
            //Unter _embeddedItems wird die Entität mit allen Feldern abgelegt
            h.push('_embeddedItems', entity);
       }
        
        
        /*
         * Prüft ob die Entität mit der angegebenen ID (die URL vornedran wird zunächst entfernt)
         * bereits an eine andere Entität vom Typ data_links.self  geknüpft ist.
         *
         * @param idWithUrl die ID der zu prüfenden Entität
         * @param functionToExecute die Funktion, die im "Negativ-Fall" (noch nicht verknüpft) aufzurufen ist
         */
        _isRelationTarget(idWithUrl, functionToExecute) {
            let baseUrl = null;
            if (this.oneToManyCheck === 'create') {
                baseUrl = this.data._links.self.href;
            } else if (this.oneToManyCheck === 'update') {
                baseUrl = this._stripIdFromUrl(this.data._links.self.href);
            } else {
                console.warn('oneToManyCheck ' + this.oneToManyCheck + ' not supported. Try create or update.');
                return;
            }

            if (!baseUrl) return;

            var methodName = 'findBy' + this._entity + 'ListOid';
            let id = this._stripUrlFromId(idWithUrl);
            let url = baseUrl + '/search/' + methodName + '?oid=' + id;
            

            var init = {
                method: 'GET',
                mode: 'cors',
                credentials: 'include'
            }

            var request = new Request(url, init);

            fetch(request)
                .then(response => {
                    if (response.ok) {
                        //OneToMany-Entity bereits in einer anderen Entität verknüpft --> Fehlermeldung
                        this._errorAlreadyAssigned('already assigned', '_isRelationTarget');

                    } else {
                        // OneToMany-Entity hat keine Verknüpfung bisher --> OK-Fall
                        functionToExecute();
                    }
                })

        }
        
        /*
         * Wird in der Komponente verwendet um den Parameter dtype
         * in einem List-Item zu überprüfen.
         */
         _itemIsOfType(item, type) {
          return (item.dtype === type);
        }
        
        _itemIsOfTypeOrNull(item, type) {
            if (!item.dtype) {
                return true;
            } else {
                return this._itemIsOfType(item, type);
            }
        }
        
            
        _confirmDeleteRowList(e) {
          this._deleteInfo = e.detail.deleteInfo;
          // find clicked item by id in _embeddedItems
          var index = this._embeddedItems.findIndex(item => item.id == e.target.id);
          // get item of row where delete button was clicked
          var item = this._embeddedItems[index];
          this._deleteItem = item;
          this.$.deleteDialogs.openSingle();
        }
        
        _deleteRow() {
           let item = this._deleteItem;
           
           //Eintrag aus data-Objekt entfernen
           let index = this._embeddedItems.findIndex(i => item.id == i.id);
           this._removeItemInternal(index);
           
           //dann erst die Relationen speichern, DANACH das Objekt selbst löschen (muss hintereinander erfolgen, sonst feuert der DB-Constraint)
           this._saveRelationData(this.data, function() {this._deleteData(item)}.bind(this));
           
        }
        
        /*
        * Löscht den über `item` identifizierten Datensatz im Backend.
        */
        _deleteData(item) {
            let link = this._toFirstLower(this._entity) + 's';
            let hal = halson(this.data);
            let baseUrl = hal.getLink(link).href;
        
            var url = baseUrl+'/'+item.id;
              // prepare request
              var init = {
                  method: 'DELETE',
                  mode: 'cors',
                  credentials: 'include'
              }
        
              var request = new Request(url, init);
              fetch(request)
              .then(response => {
                let itemId = this._stripUrlFromId(response.url);
        
                if (!response.ok) {
                  // notify user about error
                  this._error(response.status, '_loadHalData', 'list_action_delete', '', this.$t('list_delete_error', {id: itemId, code: response.status}));
                }
              }).catch(error => {
                this._error(500, '_loadHalData', 'list_action_delete');
              });
        }

        /*
         * Extrahiert aus der angegebenen Url die ID, indem es alles ab dem letzten "/" zurückgibt.
         *
         */
        _stripUrlFromId(idWithUrl) {
            return idWithUrl.substring(idWithUrl.lastIndexOf('/') + 1, idWithUrl.length);
        }

        _stripIdFromUrl(idWithUrl) {
            return idWithUrl.substring(0, idWithUrl.lastIndexOf('/'));
        }

        /*
         * Wandelt den übergebenen String so um, dass der erste Buchstabe uppercase ist.
         */
        _toFirstUpper(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }        
        
        /*
         * Wandelt den übergebenen String so um, dass der erste Buchstabe uppercase ist.
         */
        _toFirstLower(string) {
        	return string.charAt(0).toLowerCase() + string.slice(1);
        }

        /*
         * Entfernt bereits ausgewähltes Element aus
         * der Zieldatenstruktur.
         *
         * @param Event mit den notwendigen Daten
         */
        _removeItem(event) {
            //Item aus _embeddedItems entfernen
            var index = this._embeddedItems.findIndex(item => item.id == event.detail.id);
            this._removeItemInternal(index);
        }
        
        _removeItemInternal(index) {
    	    console.log("index -> " + index);
    	    this.splice('_embeddedItems', index, 1);
    	    
    	    //das data.[relationName] Array neu setzen
    	    var array = this.get('_embeddedItems');
    	    var linkArray = array.map(entity => halson(entity).getLink('self').href);
    	    //die Links auf die referenzierten Entities kommen nach data.[relationName]
    	    var refName = 'data.' + this.relationName;
    	    this.set(refName, linkArray);
        }
        
        /*
         * Der 'Toast', der beim erneuten Hinzufügen einer OneToMany-Entity angezeigt wird.
         */
         _errorAlreadyAssigned(msg, method) {
            const text = this.$t('relation_error_already_assigned');
            console.error(text+"("+msg+")");
            this._error(0, method, '', '', text);
        }
        
    }
</script>
